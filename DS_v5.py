# -*- coding: utf-8 -*-
"""DS_v5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hZU1kLYl66BsR4sBC53nKj1MPf-A5X5o

# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">Diamond Price Prediction</p>

The atoms of diamond are grouped in a crystal structure known as diamond cubic, and it is a solid form of the element carbon. The chemically stable form of carbon at room temperature and pressure is another solid form of carbon known as graphite, however diamond is metastable and converts to it at a very slow rate under those conditions. Because of its superior hardness and thermal conductivity compared to other natural materials, diamond is frequently employed in high-tech industrial products like cutting and polishing equipment. The price of Diamond is based on the carat and size. The higher the carat and the bigger the size, the price will be higher too.

The purpose to develop the diamond price prediction is to get the new knowledge from the data and predict the price.

<a id="1"></a>
# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">Import Libraries</p>
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import joblib
import tkinter as tk
from tkinter import ttk
from tkinter import filedialog
from tkinter import messagebox

from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from xgboost import XGBRegressor
from sklearn.neighbors import KNeighborsRegressor
from sklearn import metrics
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import MinMaxScaler


import warnings
warnings.filterwarnings('ignore')

"""<a id="2"></a>
# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">About Dataset</p>

<img src="data:image/jpeg;base64,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OBD68xFzB4h0bGDHw5WVQEREBERAREQEREBERAREQTe1nwWar8zVnqXr07PvuCsHmym9U1ebaz4LNV+Zqz1L16dn33BWDzZTeqagzaIiAThQ+1o/84aH/vPB6idW5PBas1jdq/XuqLfbdBRU1S3TdybWVl0q3OFK2drHsEALRl7u7JO7wGAOtBtRFEjto+8r96XP20feV+9ILVFFfbR95X70n20feV+9ILVFFfbR95X70n20feV+9ILVFFfbR95X70n20feV+9ILVFFfbR95X70n20feV+9ILVFFfbR95X70n20feV+9ILVFFfbR95X70n20feV+9ILVCor7aPvK/elwe2j7yv3pB82U425ai8zUPrJ1cLUrq/UWh9fzal13S251pulLDRT19qMhjoXRvcWOla8ZDXGQje5DhlbWgmjnhZNDIySKRocx7HbwcCMgg9YQdiJlEHlu/tTV/oH/ACSpvYn4I9L+bIfkhUl39qav9A/5JU3sT8Eel/NkPyQgrl5bx7U1f6F/+RXqWO1RK6DTVzlj4OjpJXN+EMKDBbE/BHpfzZD8kKuUjsUaW7JNLgjB9jID/wCgKuQEREBERAREQFhNYXuy2qibDqCGeemqssMUdvmq2uxjIc2NjsDiOazR5KK2pX64W+KitdtpLwG3BzhU3G32+WpdSQgd1uiNpxI7OGk8Bxd1AEKLS2orZqe2m4WSeSemEr4i6SCSIh7ThwLXtB4HhyWUWG0TJb3adporNb6y30UA6KKnq6SSne0DxteA7jzyefE5KzKAiIgIiICIiAiIgHktbQHtbbRexT3GmNUVGYPwaGvPNg8TZeY8ThyA4rZKxOsNOUOq9OVlmubSYKlm7vN76Nw4te09TmkAj4EGVC5UXsr1FW1tJV6e1I8fXFYninqyeHZLP+jqG/mvbx8hzyVogIiICIiAiIgIiICIhQYnWGoqLSum6y83Jx6ClZvbje+kdyaxvjc4kAeUrA7LNO11FS1modSNH1w314qKofi0YH2OnHkY3n5SeaxNOO2TtE7I/pNLaYmxD+BXV45v8rYuQ/OJ5rZIGEABcoiAiIgIiICx+p45JdNXOOH+kfSStbxxxLDhZBeW8e1NX+gf8koJzYs98myfTL5HOc422EkuOSe5HWq1SGxLwSaX82Q/JCr0BERAREQEREBERAREQEREE3tZ8Fmq/M1Z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"></img>

* **carat:** Weight(0.2 to 5.01) of the diamond
* **cut:** Quality of the cut (Fair, Good, Very Good, Premium, Ideal)
* **color:** Diamond colour from J(worst) to D(best)
* **clarity:** Measurement of the purity and rarity of the diamond is (I1 (worst), SI2, SI1, VS2, VS1, VVS2, VVS1, IF (best))

* **x:** Length(0 to 10.74) in mm
* **y:** Width(0 to 58.9) in mm
* **z:** Depth(0 to 31.8) in mm
* **depth %:** The height of a diamond, measured from the culet to the table, divided by its average girdle diameter. Total depth percentage(43 to 79) = z/mean(x,y) = 2\*z/(x+y)
* **table:** Width(43 to 95) of the top of diamond relative to widest point
* **price:** Price in US dollar
"""

data = pd.read_csv("diamonds.csv")
data

"""<a id="3"></a>
# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">Data Exploration</p>
"""

print(f"Shape Of The Dataset : {data.shape}")
print(f"\nGlimpse Of The Dataset :")
data.head().style.set_properties(**{"color":"black","border": "1.5px solid black"})

print(f"Informations Of The Dataset :\n")
print(data.info())

"""<a id="4"></a>
# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">Dataset Summary</p>
"""

print(f"Summary Of The Dataset :")
data.describe().style.set_properties(**{"color":"black","border": "1.5px solid black"})

print(f"Null values of the Dataset :")
data.isna().sum().to_frame().T.style.set_properties(**{"color":"black","border": "1.5px solid black"})

"""<a id="5"></a>
# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">Custom Palette For Visualization</p>
"""

sns.set_style("white")
sns.set(rc={"figure.facecolor":"white","grid.color":"white"})
sns.set_context("poster",font_scale = .7)

palette = ["#2980B9","#E67E22","#2ECC71","#E74C3C","#F1C40F","#9B59B6"]

sns.palplot(sns.color_palette(palette))
plt.show()

"""<a id="6"></a>
# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">Diamond's Price</p>
"""

print(f"Let's have a look on the distribution of prices :")
plt.subplots(figsize=(20, 8))
p = sns.histplot(data["price"],color=palette[1],kde=True,bins=30,alpha=1,fill=True,edgecolor="black",linewidth=3)
p.axes.lines[0].set_color("blue")
p.axes.set_title("\nDiamond's Price Distribution\n",fontsize=25)
plt.ylabel("Count",fontsize=20)
plt.xlabel("\nPrice ($)",fontsize=20)
plt.yscale("linear")
sns.despine(left=True, bottom=True)

plt.show()

"""<a id="7"></a>
# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">Diamond's Cut</p>
"""

plt.subplots(figsize=(12, 12))

labels = "Ideal","Premium","Very Good","Good","Fair"
size = 0.5

wedges, texts, autotexts = plt.pie([data["cut"].value_counts().values[0],
                                    data["cut"].value_counts().values[1],
                                    data["cut"].value_counts().values[2],
                                    data["cut"].value_counts().values[3],
                                    data["cut"].value_counts().values[4]],
                                    explode = (0,0,0,0,0),
                                    textprops=dict(size= 20, color= "white"),
                                    autopct="%.2f%%",
                                    pctdistance = 0.72,
                                    radius=.9,
                                    colors = ["#E67E22","#2ECC71","#E74C3C","#F1C40F","#9B59B6"],
                                    shadow = True,
                                    wedgeprops=dict(width = size, edgecolor = "black",
                                    linewidth = 4),
                                    startangle = -165)

plt.legend(wedges, labels, title="Diamond's Cut",loc="center left",bbox_to_anchor=(1, 0, 0.5, 1), edgecolor = "black")
plt.title("\nDiamond's Cut Ratio",fontsize=25)
plt.show()

# Data
labels = ["Ideal", "Premium", "Very Good", "Good", "Fair"]
values = [
    data["cut"].value_counts().values[0],
    data["cut"].value_counts().values[1],
    data["cut"].value_counts().values[2],
    data["cut"].value_counts().values[3],
    data["cut"].value_counts().values[4],
]
colors = ["#E67E22", "#2ECC71", "#E74C3C", "#F1C40F", "#9B59B6"]

# Create a bar chart
plt.figure(figsize=(12, 8))
bars = plt.bar(labels, values, color=colors, edgecolor="black", linewidth=2)

# Add data labels above the bars
for bar, value in zip(bars, values):
    plt.text(
        bar.get_x() + bar.get_width() / 2 - 0.15,
        bar.get_height() + 100,
        f"{value}",
        fontsize=12,
        color="black",
        fontweight="bold",
    )

# Add a title and labels
plt.title("\nDiamond's Cut (Bar Chart)", fontsize=18)
plt.xlabel("Diamond's Cut", fontsize=14)
plt.ylabel("Count", fontsize=14)

# Show the bar chart
plt.tight_layout()
plt.show()

plt.subplots(figsize=(25, 10))

p=sns.violinplot(x=data["cut"],y=data["price"],order=data["cut"].value_counts().index,palette=["#3f4f45","#5e9880","#f5a126","#ea5b17","#6c3938"],saturation=1,linewidth=4,edgecolor="black")
p.axes.set_title("\nDiamond's Price On Cut\n",fontsize=30)
p.axes.set_xlabel("\nCut",fontsize=25)
p.axes.set_ylabel("Price",fontsize=25)

sns.despine(left=True, bottom=True)
plt.show()

"""<a id="8"></a>
# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">Diamond's Color</p>
"""

plt.subplots(figsize=(8, 8))

labels = "G","E","F","H","D","I","J"
size = 0.6

fig = plt.gcf()
fig.patch.set_facecolor('#ffffff')

wedges, texts, autotexts = plt.pie([data["color"].value_counts().values[0],
                                    data["color"].value_counts().values[1],
                                    data["color"].value_counts().values[2],
                                    data["color"].value_counts().values[3],
                                    data["color"].value_counts().values[4],
                                    data["color"].value_counts().values[5],
                                    data["color"].value_counts().values[6]],
                                    explode = (0,0,0,0,0,0,0),
                                    textprops=dict(size= 14, color= "black"),
                                    autopct="%.2f%%",
                                    pctdistance = 0.72,
                                    radius=.9,
                                    colors = ["#34f20a","#5e9880","#f20a29","#f5a126","#b05f0d","#f2ea0a","#ea0af2"],
                                    shadow = True,
                                    wedgeprops=dict(width = size, edgecolor = "black",
                                    linewidth = 4),
                                    startangle = -125)

plt.legend(wedges, labels, title="Diamond's Color",loc="center left",bbox_to_anchor=(1, 0, 0.5, 1), edgecolor = "black")
plt.title("\nDiamond's Color Ratio",fontsize=25)
plt.show()

plt.subplots(figsize=(20, 8))

fig = plt.gcf()
fig.patch.set_facecolor('#ffffff')

p=sns.countplot(y=data["color"],order=data["color"].value_counts().index,palette=
                ["#34f20a","#5e9880","#f20a29","#f5a126","#b05f0d","#f2ea0a","#ea0af2"],
                saturation=1, edgecolor = "#1c1c1c", linewidth = 5)

p.axes.set_title("\nDiamond's Color\n",fontsize=25)
p.axes.set_ylabel("Color",fontsize=20)
p.axes.set_xlabel("\nTotal",fontsize=20)
p.axes.set_yticklabels(p.get_yticklabels(),rotation = 0)
for container in p.containers:
    p.bar_label(container,label_type="center",padding=6,size=25,color="black",rotation=0,
    bbox={"boxstyle": "round", "pad": 0.3, "facecolor": "#e0b583", "edgecolor": "#1c1c1c", "linewidth" : 1, "alpha": 1})


sns.despine(left=True, bottom=True)
plt.show()

plt.subplots(figsize=(25, 10))

fig = plt.gcf()
fig.patch.set_facecolor('#ffffff')


p=sns.violinplot(x=data["color"],y=data["price"],order=data["color"].value_counts().index,palette=
                 ["#34f20a","#5e9880","#f20a29","#f5a126","#b05f0d","#f2ea0a","#ea0af2"],
                 saturation=1,linewidth=4,edgecolor="black")
p.axes.set_title("\nDiamond's Price On Color\n",fontsize=30)
p.axes.set_xlabel("\nColor",fontsize=25)
p.axes.set_ylabel("Price",fontsize=25)

sns.despine(left=True, bottom=True)

plt.show()

"""<a id="9"></a>
# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">Diamond's Clarity</p>
"""

plt.subplots(figsize=(12, 12))

fig = plt.gcf()
fig.patch.set_facecolor('#ffffff')

labels = "SI1","VS2","SI2","VS1","VVS2","VVS1","IF","I1"
size = 0.6

wedges, texts, autotexts = plt.pie([data["clarity"].value_counts().values[0],
                                    data["clarity"].value_counts().values[1],
                                    data["clarity"].value_counts().values[2],
                                    data["clarity"].value_counts().values[3],
                                    data["clarity"].value_counts().values[4],
                                    data["clarity"].value_counts().values[5],
                                    data["clarity"].value_counts().values[6],
                                    data["clarity"].value_counts().values[7]],
                                    explode = (0,0,0,0,0,0,0,0),
                                    textprops=dict(size= 15, color= "white"),
                                    autopct="%.2f%%",
                                    pctdistance = 0.70,
                                    radius=.8,
                                    colors = ["#024dfa","#5e9880","#f20a29","#f5a126","#b05f0d","#03a61c","#ea0af2","#4c03a6"],
                                    shadow = True,
                                    wedgeprops=dict(width = size, edgecolor = "black",
                                    linewidth = 4),
                                    startangle = -230)

plt.legend(wedges, labels, title="Diamond's Clarity",loc="center left",bbox_to_anchor=(1, 0, 0.5, 1), edgecolor = "black")
plt.title("\nDiamond's Clarity Ratio",fontsize=30)
plt.show()

plt.subplots(figsize=(20, 10))

fig = plt.gcf()
fig.patch.set_facecolor('#ffffff')

p=sns.countplot(y=data["clarity"],order=data["clarity"].value_counts().index,palette=
                ["#024dfa","#5e9880","#f20a29","#f5a126","#b05f0d","#03a61c","#ea0af2","#4c03a6"],
                saturation=1, edgecolor = "#1c1c1c", linewidth = 5)

p.axes.set_title("\nDiamond's Clarity\n",fontsize=25)
p.axes.set_ylabel("Clarity",fontsize=20)
p.axes.set_xlabel("\nTotal",fontsize=20)
p.axes.set_yticklabels(p.get_yticklabels(),rotation = 0)
for container in p.containers:
    p.bar_label(container,label_type="center",padding=6,size=22,color="black",rotation=0,
    bbox={"boxstyle": "round", "pad": 0.2, "facecolor": "#e0b583", "edgecolor": "#1c1c1c", "linewidth" : 3, "alpha": 1})


sns.despine(left=True, bottom=True)
plt.show()

plt.subplots(figsize=(25, 10))

fig = plt.gcf()
fig.patch.set_facecolor('#ffffff')

p=sns.violinplot(x=data["clarity"],y=data["price"],order=data["clarity"].value_counts().index,palette=
                 ["#024dfa","#5e9880","#f20a29","#f5a126","#b05f0d","#03a61c","#ea0af2","#4c03a6"],
                 saturation=1,linewidth=4,edgecolor="black")
p.axes.set_title("\nDiamond's Price On Clarity\n",fontsize=30)
p.axes.set_xlabel("\nClarity",fontsize=25)
p.axes.set_ylabel("Price",fontsize=25)

sns.despine(left=True, bottom=True)
plt.show()

"""<a id="10"></a>
# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">Diamond's Weight</p>
"""

import matplotlib.pyplot as plt

# Assuming you have a DataFrame 'data' with 'carat' and 'price' columns
plt.figure(figsize=(10, 6))
plt.scatter(data['carat'], data['price'], alpha=0.5, color='blue')
plt.title("Scatter Plot of Carat vs. Price")
plt.xlabel("Carat")
plt.ylabel("Price")
plt.grid(True)
plt.show()

plt.subplots(figsize=(20, 8))
p = sns.histplot(data["carat"],color="#3f4f45",kde=True,bins=30,alpha=1,fill=True,edgecolor="black",linewidth=3)
p.axes.lines[0].set_color("orange")
p.axes.set_title("\nDiamond's Weight In Carat Distribution\n",fontsize=25)
plt.ylabel("Count",fontsize=20)
plt.xlabel("\nWeights In Carat",fontsize=20)
# plt.yscale("linear")
sns.despine(left=True, bottom=True)

plt.show()

_, axes = plt.subplots(figsize=(20, 8))
sns.kdeplot(data=data, x="price", y="carat", edgecolor="#1c1c1c", fill=True, kind="kde", shade=True, height=10, color="#3f4f45")
axes.set_title("\nPrice Distribution Of Weights\n", fontsize=25)
axes.set_xlabel("\nPrice", fontsize=20)
axes.set_ylabel("Weights In Carat", fontsize=20)

sns.despine(left=True, bottom=True)
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Assuming you have a DataFrame 'data' with 'clarity' and 'price' columns
plt.figure(figsize=(10, 6))
sns.boxplot(x='clarity', y='price', data=data, palette='Set3')
plt.title("Box Plot of Price by Diamond Clarity")
plt.xlabel("Clarity")
plt.ylabel("Price")
plt.grid(True)
plt.show()
#pending

"""
<a id="11"></a>
# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">Diamond's Depth Percentage</p>
"""

# KDE Plot - distribution of depth percentage
plt.figure(figsize=(12, 6))
p = sns.histplot(data=data, x="depth", bins=30, kde=True, color="#f2c4d6", edgecolor="black")

plt.title("\nDistribution of Diamond Depth Percentages\n", fontsize=16)
plt.xlabel("\nDepth Percentage", fontsize=14)
plt.ylabel("Count", fontsize=14)
p.axes.lines[0].set_color("black")
p.axes.lines[0].set_linewidth(2)

plt.show()

# jointplot to show the relationship between price and depth percentage

sns.set(style="whitegrid")
g = sns.jointplot(data=data, x="depth", y="price", kind="kde", cmap="YlGnBu", height=8, shade=True)
# can change kind = "scatter" or kind = "reg"

# Customize plot labels and title
g.ax_joint.set_xlabel("Depth Percentage", fontsize=14)
g.ax_joint.set_ylabel("Price", fontsize=14)
g.fig.suptitle("Price Distribution by Depth Percentage", fontsize=16)

plt.show()

"""
<a id="12"></a>
# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">Diamond's Table</p>
"""

plt.figure(figsize=(12, 6))
p = sns.histplot(data=data, x="table", bins=28, kde=True, color="#f2c4d6", edgecolor="black")

# Customize plot labels and title
plt.title("Distribution of Diamond Table Values", fontsize=16)
plt.xlabel("Table Value", fontsize=14)
plt.ylabel("Count", fontsize=14)
p.axes.lines[0].set_color("black")
p.axes.lines[0].set_linewidth(2)

# Show the plot
plt.show()

# KDE plot with price on the x-axis and table on the y-axis
plt.figure(figsize=(12, 6))
sns.kdeplot(data=data, x="price", y="table", fill=True, cmap="YlGnBu", shade=True)

# Customize plot labels and title
plt.title("Price Distribution of Diamond's Table", fontsize=16)
plt.xlabel("Price", fontsize=14)
plt.ylabel("Diamond's Table", fontsize=14)

# Show the plot
plt.show()

"""<a id="13"></a>
# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">Outliers</p>
"""

sns.pairplot(data=data,hue="cut",palette=["#9e0142","#fdae61","#66c2a5","#5e4fa2","#e781b0"],plot_kws=dict(linewidth=0))
sns.despine(left=True, bottom=True)
plt.show()

_, axs = plt.subplots(2,3,figsize=(25,12),sharex=True)
plt.tight_layout(pad=4.0)

sns.regplot(x="price", y="'x'", data=data, ax=axs[0,0], color="#9e0142", fit_reg=True, line_kws=dict(color= "orange"))
axs[0,0].set_title("Price vs Length\n",fontsize=25)
axs[0,0].set_ylabel("x",fontsize=20)

sns.regplot(x="price", y="'y'", data=data, ax=axs[0,1], color="#fdae61", fit_reg=True, line_kws=dict(color= "orange"))
axs[0,1].set_title("Price vs Width\n",fontsize=25)
axs[0,1].set_ylabel("y",fontsize=20)

sns.regplot(x="price", y="'z'", data=data, ax=axs[0,2], color="#66c2a5", fit_reg=True, line_kws=dict(color= "orange"))
axs[0,2].set_title("Price vs Depth\n",fontsize=25)
axs[0,2].set_ylabel("z",fontsize=20)

sns.regplot(x="price", y="depth", data=data, ax=axs[1,0], color="#5e4fa2", fit_reg=True, line_kws=dict(color= "#6c3938"))
axs[1,0].set_title("Price vs Depth Percentage\n",fontsize=25)
axs[1,0].set_xlabel("\nPrice",fontsize=20)
axs[1,0].set_ylabel("depth",fontsize=20)

sns.regplot(x="price", y="table", data=data, ax=axs[1,1], color="#e781b0", fit_reg=True, line_kws=dict(color= "#6c3938"))
axs[1,1].set_title("Price vs Table\n",fontsize=25)
axs[1,1].set_xlabel("\nPrice",fontsize=20)
axs[1,1].set_ylabel("Table",fontsize=20)

sns.regplot(x="price", y="carat", data=data, ax=axs[1,2], color="#a52b5d", fit_reg=True, line_kws=dict(color= "orange"))
axs[1,2].set_title("Price vs Weight\n",fontsize=25)
axs[1,2].set_xlabel("\nPrice",fontsize=20)
axs[1,2].set_ylabel("carat",fontsize=20)

plt.suptitle("Regression Line\n\n",fontsize=30, y=1.03)
sns.despine(left=True, bottom=True)
plt.show()

data = data[(data["'x'"]<10)&(data["'x'"]>3)]
data = data[(data["'y'"]<13)&(data["'y'"]>2)]
data = data[(data["'z'"]<6)&(data["'z'"]>2)]
data = data[(data["depth"]<73)&(data["depth"]>53)]
data = data[(data["table"]<71)&(data["table"]>50)]
data = data[(data["carat"]<3)]

print(f"After dropping outliers, let's have a look on the pairwise relationships :")

sns.pairplot(data=data,hue="cut",palette=["#9e0142","#e6f598","#66c2a5","#5e4fa2","#e781b0"],plot_kws=dict(linewidth=0))
sns.despine(left=True, bottom=True)
plt.show()

"""
<a id="14"></a>
# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">Correlation</p>"""

catcol = ["color","clarity","cut"]
le = LabelEncoder()
for col in catcol:
        data[col] = le.fit_transform(data[col])


plt.subplots(figsize =(12, 12))

sns.heatmap(data.corr(), cmap = "magma", square=True, cbar_kws=dict(shrink =.82), annot=True, vmin=-1,
            vmax=1, linewidths=3,linecolor='#3f4f45',annot_kws=dict(fontsize =12))
plt.title("Pearson Correlation Of Features\n", fontsize=25)
plt.xticks(rotation=90)
plt.yticks(rotation=0)
plt.show()

"""<a id="14"></a>
# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">Normalisation</p>
"""

# Specify the columns to be scaled (exclude non-numeric columns)
numeric_columns = ['carat', "'x'", "'y'", "'z'"]
scaler = MinMaxScaler()
data[numeric_columns] = scaler.fit_transform(data[numeric_columns])

print(data)

"""<a id="14"></a>
# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">Spliting Data</p>
"""

# Drop the columns you don't need
columns_to_drop = ['cut','depth', 'table']
data = data.drop(columns=columns_to_drop)

# Handle missing values (NaN) if there are any
# For example, you can fill NaN values with the mean of each column
data.fillna(data.mean(), inplace=True)

print(data)
# Drop the target variable from the feature dataset
X = data.drop(columns='price')
# Assuming 'price' is your target variable
y = data["price"]

# Standardize the features using StandardScaler
scaler = StandardScaler()
X = scaler.fit_transform(X)

# Split the data into training and testing sets
x_train, x_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""<a id="15"></a>
# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">Model Creation & Performance Evaluation</p>

## Random Forest
"""

rf = RandomForestRegressor()
rf.fit(x_train,y_train)
rf_pred = rf.predict(x_test)


print("After Performing Random Forest Regression,\n")
print(f"R Squared Value: {metrics.r2_score(y_test,rf_pred)}")
rfr1 =1-(1-metrics.r2_score(y_test,rf_pred))*(len(y_test)-1)/(len(y_test)-x_test.shape[1]-1)
print(f"Adjusted R Squared Value: {1-(1-metrics.r2_score(y_test,rf_pred))*(len(y_test)-1)/(len(y_test)-x_test.shape[1]-1)}")
print(f"Mean Absolute Error: {metrics.mean_absolute_error(y_test,rf_pred)}")
print(f"Mean Squared Error: {metrics.mean_squared_error(y_test,rf_pred)}")
print(f"Root Mean Squared Error: {metrics.mean_squared_error(y_test,rf_pred,squared = False)}")

# Create a scatter plot
plt.figure(figsize=(10, 6))
plt.scatter(y_test, rf_pred, alpha=0.5, color='b',s=40, label='Actual vs. Predicted Prices')
plt.xlabel('Actual Prices', fontsize=14)
plt.ylabel('Predicted Prices', fontsize=14)
plt.title('Random Forest Regression', fontsize=16)
plt.legend()
plt.grid(True)

# Add a diagonal line (perfect prediction line)
plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], linestyle='--', color='r', linewidth=2, label='Perfect Prediction')

# Show the plot
plt.legend()
plt.show()

# Calculate the residuals
residuals = y_test - rf_pred

# Create the residual plot
plt.figure(figsize=(10, 6))
plt.scatter(y_test, residuals, alpha=0.5, color='b', s=40)
plt.xlabel("Predicted Values")
plt.ylabel("Residuals")
plt.title("Residual Plot")
plt.axhline(0, color='red', linestyle='--', linewidth=2)

plt.show()


# Plot 2: Distribution of Residuals (Histogram)
plt.figure(figsize=(8, 6))
sns.histplot(y_test - rf_pred, kde=True)
plt.xlabel('Residuals')
plt.ylabel('Frequency')
plt.title('Distribution of Residuals')
plt.grid(True)
plt.show()

"""## K-Neighbours Regression"""

kn = KNeighborsRegressor()
kn.fit(x_train,y_train)
kn_pred = kn.predict(x_test)

print("After Performing K-Neighbors Regression,\n")
print(f"R Squared Value: {metrics.r2_score(y_test,kn_pred)}")
knr2 = 1-(1-metrics.r2_score(y_test,kn_pred))*(len(y_test)-1)/(len(y_test)-x_test.shape[1]-1)
print(f"Adjusted R Squared Value: {1-(1-metrics.r2_score(y_test,kn_pred))*(len(y_test)-1)/(len(y_test)-x_test.shape[1]-1)}")
print(f"Mean Absolute Error: {metrics.mean_absolute_error(y_test,kn_pred)}")
print(f"Mean Squared Error: {metrics.mean_squared_error(y_test,kn_pred)}")
print(f"Root Mean Squared Error: {metrics.mean_squared_error(y_test,kn_pred,squared = False)}")

# Plot 3: Actual vs. Predicted Values (Scatter Plot)
plt.figure(figsize=(8, 6))
sns.scatterplot(x=y_test, y=kn_pred, color='b')
plt.xlabel('Actual Values')
plt.ylabel('Predicted Values')
plt.title('K-Neighbors Regression')
plt.grid(True)

plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], color='red', linestyle='--')

plt.show()

# Plot 4: Regression Line (Regression Plot)
# plt.figure(figsize=(8, 6))
# sns.regplot(x=y_test, y=kn_pred, line_kws={"color": "yellow"})
# plt.xlabel('Actual Values')
# plt.ylabel('Predicted Values')
# plt.title('Regression Line')
# plt.grid(True)
# plt.show()
# sns.set()
# plt.close()

# Plot 1: Residuals vs. Predictions (Scatter Plot)
residuals = y_test - kn_pred

plt.figure(figsize=(8, 6))
sns.scatterplot(x=kn_pred, y=residuals)
plt.xlabel('Predictions')
plt.ylabel('Residuals')
plt.title('Residual Plot')
plt.grid(True)
median_residual = np.median(residuals)
plt.axhline(0, color='red', linestyle='--', linewidth=2)

plt.show()

# Plot 2: Distribution of Residuals (Histogram)
plt.figure(figsize=(8, 6))
sns.histplot(y_test - kn_pred, kde=True)
plt.xlabel('Residuals')
plt.ylabel('Frequency')
plt.title('Distribution of Residuals')
plt.grid(True)
plt.show()

"""## Decision Tree"""

dt = DecisionTreeRegressor()
dt.fit(x_train,y_train)
DT_pred = dt.predict(x_test)

print("After Performing Decision Tree Regression,\n")
print(f"R Squared Value: {metrics.r2_score(y_test,DT_pred)}")
dtr=1-(1-metrics.r2_score(y_test,DT_pred))*(len(y_test)-1)/(len(y_test)-x_test.shape[1]-1)
print(f"Adjusted R Squared Value: {1-(1-metrics.r2_score(y_test,DT_pred))*(len(y_test)-1)/(len(y_test)-x_test.shape[1]-1)}")
print(f"Mean Absolute Error: {metrics.mean_absolute_error(y_test,DT_pred)}")
print(f"Mean Squared Error: {metrics.mean_squared_error(y_test,DT_pred)}")
print(f"Root Mean Squared Error: {metrics.mean_squared_error(y_test,DT_pred,squared = False)}")

# Create the predicted and actual values
DT_pred = np.array(DT_pred)
y_test = np.array(y_test)

# Create the scatter plot
plt.figure(figsize=(10, 6))
plt.scatter(y_test, DT_pred, alpha=0.5, color='b', s=40, label='Actual vs. Predicted Prices')
plt.xlabel('Actual Prices ($)', fontsize=14)
plt.ylabel('Predicted Prices ($)', fontsize=14)
plt.title('Decision Tree Regression', fontsize=16)

# Add a diagonal line (perfect prediction line)
plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], linestyle='--', color='red', linewidth=2, label='Perfect Prediction')

plt.legend()
plt.show()

# Calculate the residuals
residuals = y_test - DT_pred

# Create the residual plot
plt.figure(figsize=(10, 6))
plt.scatter(y_test, residuals, alpha=0.5, color='b', s=40)
plt.xlabel("Predicted Values")
plt.ylabel("Residuals")
plt.title("Residual Plot")
plt.axhline(0, color='red', linestyle='--', linewidth=2)

plt.show()

# Plot 2: Distribution of Residuals (Histogram)
plt.figure(figsize=(8, 6))
sns.histplot(y_test - DT_pred, kde=True)
plt.xlabel('Residuals')
plt.ylabel('Frequency')
plt.title('Distribution of Residuals')
plt.grid(True)
plt.show()

"""## XGBoost"""

xr = XGBRegressor()
xr.fit(x_train,y_train)
xgb_pred = xr.predict(x_test)


print("After Performing XGBoost Regression,\n")
print(f"R Squared Value: {metrics.r2_score(y_test,xgb_pred)}")
xg = 1-(1-metrics.r2_score(y_test,xgb_pred))*(len(y_test)-1)/(len(y_test)-x_test.shape[1]-1)
print(f"Adjusted R Squared Value: {1-(1-metrics.r2_score(y_test,xgb_pred))*(len(y_test)-1)/(len(y_test)-x_test.shape[1]-1)}")
print(f"Mean Absolute Error: {metrics.mean_absolute_error(y_test,xgb_pred)}")
print(f"Mean Squared Error: {metrics.mean_squared_error(y_test,xgb_pred)}")
print(f"Root Mean Squared Error: {metrics.mean_squared_error(y_test,xgb_pred,squared = False)}")

# Create the predicted and actual values
xgb_pred = np.array(xgb_pred)
y_test = np.array(y_test)

# Create the scatter plot
plt.figure(figsize=(10, 6))
plt.scatter(y_test, xgb_pred, alpha=0.5, color='b', s=40, label='Actual vs. Predicted Prices')
plt.xlabel('Actual Prices ($)', fontsize=14)
plt.ylabel('Predicted Prices ($)', fontsize=14)
plt.title('XGBoost', fontsize=16)

# Add a diagonal line (perfect prediction line)
plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], linestyle='--', color='red', linewidth=2, label='Perfect Prediction')

plt.legend()
plt.show()

# Plot 2: Distribution of Residuals (Histogram)
plt.figure(figsize=(8, 6))
sns.histplot(y_test - xgb_pred, kde=True)
plt.xlabel('Residuals')
plt.ylabel('Frequency')
plt.title('Distribution of Residuals')
plt.grid(True)
plt.show()

# Calculate the residuals
residuals = y_test - xgb_pred

# Create the residual plot
plt.figure(figsize=(10, 6))
plt.scatter(y_test, residuals, alpha=0.5, color='b', s=40)
plt.xlabel("Predicted Values")
plt.ylabel("Residuals")
plt.title("Residual Plot")
plt.axhline(0, color='red', linestyle='--', linewidth=2)

plt.show()

"""## The Best Performance Model"""

# Data
categories = ['Random Forest', 'Decision Tree', 'XGBoost', 'K-Neighbours']
values = [rfr1, dtr, xg, knr2]

# Create a bar chart
plt.bar(categories, values, color=['blue', 'green', 'red', 'brown'])

# Add labels and a title
plt.xlabel('Models', fontsize=14)
plt.ylabel('Values', fontsize=14)

for i, v in enumerate(values):
    formatted_value = "{:.4f}".format(v)
    plt.text(i, v + 0.02, formatted_value, ha='center', va='bottom', fontsize=12, color='black')

# Show the plot
plt.show()

#conclusion
highest_value = max(values)
highest_category = categories[values.index(highest_value)]
print(f"The best performance model is {highest_category} with {highest_value:.4f}")

"""<a id="16"></a>
# <p style="padding:10px;background-color:#D198C5FF;margin:0;color:#111423;font-family:newtimeroman;font-size:150%;text-align:center;overflow:hidden;font-weight:500">Prediction</p>
"""

# First subplot (left)
rf = XGBRegressor()
rf.fit(x_train,y_train)
y_pred = xr.predict(x_test)
plt.figure(figsize=(15, 6))  # Set the figure size
plt.subplot(1, 2, 1)  # 1 row, 2 columns, first subplot

# Create a scatter plot for the first subplot
plt.scatter(y_test, y_pred, alpha=0.5, color='b', label='Actual vs. Predicted Prices')
plt.xlabel('Actual Prices', fontsize=14)
plt.ylabel('Predicted Prices', fontsize=14)
plt.title('All Actual vs. Predicted Diamond Prices', fontsize=16)
plt.legend()
plt.grid(True)

# Second subplot (right)===========================================================================================
randomly_selected_data = data.sample(frac=0.80, random_state=42)
sc = StandardScaler()

# For example, you can fill NaN values with the mean of each column
x=randomly_selected_data.drop(columns='price')
x = sc.fit_transform(x)
y= randomly_selected_data["price"]
x_train1, x_test1, y_train1, y_test1 = train_test_split(x, y, test_size=0.2, random_state=42)

rf = XGBRegressor()
rf.fit(x_train1,y_train1)
y_pred1 = xr.predict(x_test1)


plt.subplot(1, 2, 2)  # 1 row, 2 columns, second subplot
# Create a scatter plot for the second subplot
plt.scatter(y_test1, y_pred1, alpha=0.5, color='b', label='Actual vs. Predicted Prices')
plt.xlabel('Actual Prices', fontsize=14)
plt.ylabel('Predicted Prices', fontsize=14)
plt.title('Randomly Selected Actual vs. Predicted Diamond Prices', fontsize=16)
plt.legend()
plt.grid(True)

# Adjust the layout to avoid overlap
plt.tight_layout()

# Show the combined plot
plt.show()

"""## UI

https://predictdiamondprice-3fdnfppz3klbbg6674z9uh.streamlit.app/
"""

# Train the XGBRegressor
xr = XGBRegressor()
xr.fit(x_train, y_train)

# Save the trained model to a file
joblib.dump(xr, 'model.pkl')

# Load your trained scikit-learn KNeighborsRegressor model here
model = joblib.load('model.pkl')

# Dictionary to encode color and clarity
color_encoding = {"b'J'": 1, "b'I'": 2, "b'H'": 3, "b'G'": 4, "b'F'": 5, "b'E'": 6, "b'D'": 7}
clarity_encoding = {"b'I1'": 1, "b'SI2'": 2, "b'SI1'": 3, "b'VS2'": 4, "b'VS1'": 5, "b'VVS2'": 6, "b'VVS1'": 7, "b'IF'": 8}
def encode_color(color):
    return color_encoding.get(color, 0)  # Default to 0 if color is not found

def encode_clarity(clarity):
    return clarity_encoding.get(clarity, 0)  # Default to 0 if clarity is not found

def predict_price(row):
    try:
        # Extract values from the row
        carat = float(row[0])
        color = encode_color(row[2])  # Encode color
        clarity = encode_clarity(row[3])  # Encode clarity
        x = float(row[6])
        y = float(row[7])
        z = float(row[8])

        # Make price predictions using the model
        input_data = np.array([carat, color, clarity, x, y, z]).reshape(1, -1)
        print(input_data)
        predicted_price = model.predict(input_data)

        return predicted_price[0]
    except Exception as e:
        messagebox.showerror("Prediction Error", f"An error occurred while making predictions: {str(e)}")
        return None

def bulk_import_and_predict():
    # Open a file dialog for the user to select a dataset file (CSV format)
    file_path = filedialog.askopenfilename(filetypes=[("Excel Files", "*.xlsx *.xls"), ("CSV Files", "*.csv")])

    if file_path:
        try:
            if file_path.endswith('.xlsx') or file_path.endswith('.xls'):
                df = pd.read_excel(file_path, header=None)
            elif file_path.endswith('.csv'):
                df = pd.read_csv(file_path, header=None)

            # Predict prices for each row and add a new column 'Predicted Price' to the dataset
            df['Predicted Price'] = df.apply(predict_price, axis=1)

            # Display the dataset with predictions in a new window
            show_dataset_window(df)

            # Optionally, you can save the dataset with predictions to a new CSV file.
            # df.to_csv('predicted_dataset.csv', index=False)

        except Exception as e:
            messagebox.showerror("Import Error", f"An error occurred while importing the dataset: {str(e)}")

def show_dataset_window(dataset):
    dataset_window = tk.Toplevel()
    dataset_window.title("Imported Dataset with Predictions")

    # Create a Treeview widget to display the dataset
    tree = ttk.Treeview(dataset_window)

    # Define columns with headings
    columns_with_headings = [
        "carat","cut", "color", "clarity", "depth", "table", "x", "y", "z", "price"
    ]

    # Set column headings
    tree["columns"] = columns_with_headings

    # Configure columns
    for column in columns_with_headings:
        tree.column(column, anchor="w", width=100)
        tree.heading(column, text=column, anchor="w")

    # Insert data rows
    for _, row in dataset.iterrows():
        tree.insert("", "end", values=list(row))

    tree.pack(fill="both", expand=True)

# Create the Tkinter window
cut_mapping = {"Fair": 1, "Good": 2, "Very Good": 3, "Premium": 4, "Ideal": 5}
color_mapping = {"J": 1, "I": 2, "H": 3, "G": 4, "F": 5, "E": 6, "D": 7}
clarity_mapping = {"I1": 1, "SI2": 2, "SI1": 3, "VS2": 4, "VS1": 5, "VVS2": 6, "VVS1": 7, "IF": 8}

def predict_diamond_price():
    try:
        carat = float(carat_scale.get())

        # Check if any combobox is left blank
        if not cut_combobox.get() or not color_combobox.get() or not clarity_combobox.get():
            raise ValueError("Please select values for Cut, Color, and Clarity.")

        cut = cut_mapping[cut_combobox.get()]  # Map combobox value to numeric value
        color = color_mapping[color_combobox.get()]  # Map combobox value to numeric value
        clarity = clarity_mapping[clarity_combobox.get()]  # Map combobox value to numeric value
        depth = float(depth_scale.get())
        table = float(table_scale.get())
        x = float(x_scale.get())
        y = float(y_scale.get())
        z = float(z_scale.get())

        user_input = np.array([carat, color, clarity, x, y, z]).reshape(1, -1)
        print(user_input)
        predicted_price = model.predict(user_input)

        # Update the label with a larger font and red color
        predicted_label.config(text=f'Predicted Price: ${predicted_price[0]:.2f}', font=("Helvetica", 16), fg="red")

    except ValueError as e:
        messagebox.showerror("Error", str(e))




# Create the Tkinter window
window = tk.Tk()
window.title("Diamond Price Prediction")
window.geometry("400x650")  # Set the initial window size

# Labels and input fields
carat_label = tk.Label(window, text="Carat:")
carat_label.pack()

# Use ttk.Scale for carat input
carat_scale = ttk.Scale(window, from_=0.2, to=5.01, length=200, orient="horizontal")
carat_scale.pack()

# Label to display carat value
carat_value_label = ttk.Label(window, text="0.2")
carat_value_label.pack()

def update_carat_value(value):
    carat_value_label.config(text=f"{value:.2f}")

carat_scale.config(command=lambda value: update_carat_value(carat_scale.get()))

# Depth
depth_label = tk.Label(window, text="Depth:")
depth_label.pack()
depth_scale = ttk.Scale(window, from_=40, to=80, length=200, orient="horizontal")
depth_scale.pack()
depth_value_label = ttk.Label(window, text="40")
depth_value_label.pack()

cut_label = tk.Label(window, text="Cut:")
cut_label.pack()
cut_options = ["Fair", "Good", "Very Good", "Premium", "Ideal"]
cut_combobox = ttk.Combobox(window, values=cut_options)
cut_combobox.pack()

color_label = tk.Label(window, text="Color:")
color_label.pack()
color_options = ["J", "I", "H", "G", "F", "E", "D"]
color_combobox = ttk.Combobox(window, values=color_options)
color_combobox.pack()

clarity_label = tk.Label(window, text="Clarity:")
clarity_label.pack()
clarity_options = ["I1", "SI2", "SI1", "VS2", "VS1", "VVS2", "VVS1", "IF"]
clarity_combobox = ttk.Combobox(window, values=clarity_options)
clarity_combobox.pack()


def update_depth_value(value):
    depth_value_label.config(text=f"{value:.2f}")

depth_scale.config(command=lambda value: update_depth_value(depth_scale.get()))

# Table
table_label = tk.Label(window, text="Table:")
table_label.pack()
table_scale = ttk.Scale(window, from_=50, to=80, length=200, orient="horizontal")
table_scale.pack()
table_value_label = ttk.Label(window, text="50")
table_value_label.pack()

def update_table_value(value):
    table_value_label.config(text=f"{value:.2f}")

table_scale.config(command=lambda value: update_table_value(table_scale.get()))

# Length (mm)
x_label = tk.Label(window, text="Length (mm):")
x_label.pack()
x_scale = ttk.Scale(window, from_=0, to=10, length=200, orient="horizontal")
x_scale.pack()
x_value_label = ttk.Label(window, text="0")
x_value_label.pack()

def update_x_value(value):
    x_value_label.config(text=f"{value:.2f}")

x_scale.config(command=lambda value: update_x_value(x_scale.get()))

# Width (mm)
y_label = tk.Label(window, text="Width (mm):")
y_label.pack()
y_scale = ttk.Scale(window, from_=0, to=10, length=200, orient="horizontal")
y_scale.pack()
y_value_label = ttk.Label(window, text="0")
y_value_label.pack()

def update_y_value(value):
    y_value_label.config(text=f"{value:.2f}")

y_scale.config(command=lambda value: update_y_value(y_scale.get()))

# Depth (mm)
z_label = tk.Label(window, text="Depth (mm):")
z_label.pack()
z_scale = ttk.Scale(window, from_=0, to=10, length=200, orient="horizontal")
z_scale.pack()
z_value_label = ttk.Label(window, text="0")
z_value_label.pack()

def update_z_value(value):
    z_value_label.config(text=f"{value:.2f}")

z_scale.config(command=lambda value: update_z_value(z_scale.get()))


# Predict button
predict_button = tk.Button(window, text="Predict Diamond Price", command=predict_diamond_price)
predict_button.pack()

# Display predicted price
predicted_label = tk.Label(window, text="", font=("Helvetica", 16), fg="red")
predicted_label.pack()



# Create a "Bulk Import" button
bulk_import_button = tk.Button(window, text="Bulk Import and Predict", command=bulk_import_and_predict)
bulk_import_button.pack()

# Start the Tkinter main loop
window.mainloop()

